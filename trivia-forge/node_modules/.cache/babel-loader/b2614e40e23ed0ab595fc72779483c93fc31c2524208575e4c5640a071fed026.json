{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_connectedPromise, _AbstractChatCompletionRunner_resolveConnectedPromise, _AbstractChatCompletionRunner_rejectConnectedPromise, _AbstractChatCompletionRunner_endPromise, _AbstractChatCompletionRunner_resolveEndPromise, _AbstractChatCompletionRunner_rejectEndPromise, _AbstractChatCompletionRunner_listeners, _AbstractChatCompletionRunner_ended, _AbstractChatCompletionRunner_errored, _AbstractChatCompletionRunner_aborted, _AbstractChatCompletionRunner_catchingPromiseCreated, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_handleError, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;\nimport { APIUserAbortError, OpenAIError } from 'openai/error';\nimport { isRunnableFunctionWithParse } from \"./RunnableFunction.mjs\";\nimport { isAssistantMessage, isFunctionMessage, isToolMessage } from \"./chatCompletionUtils.mjs\";\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nexport class AbstractChatCompletionRunner {\n  constructor() {\n    _AbstractChatCompletionRunner_instances.add(this);\n    this.controller = new AbortController();\n    _AbstractChatCompletionRunner_connectedPromise.set(this, void 0);\n    _AbstractChatCompletionRunner_resolveConnectedPromise.set(this, () => {});\n    _AbstractChatCompletionRunner_rejectConnectedPromise.set(this, () => {});\n    _AbstractChatCompletionRunner_endPromise.set(this, void 0);\n    _AbstractChatCompletionRunner_resolveEndPromise.set(this, () => {});\n    _AbstractChatCompletionRunner_rejectEndPromise.set(this, () => {});\n    _AbstractChatCompletionRunner_listeners.set(this, {});\n    this._chatCompletions = [];\n    this.messages = [];\n    _AbstractChatCompletionRunner_ended.set(this, false);\n    _AbstractChatCompletionRunner_errored.set(this, false);\n    _AbstractChatCompletionRunner_aborted.set(this, false);\n    _AbstractChatCompletionRunner_catchingPromiseCreated.set(this, false);\n    _AbstractChatCompletionRunner_handleError.set(this, error => {\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_errored, true, \"f\");\n      if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n      }\n      if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _AbstractChatCompletionRunner_aborted, true, \"f\");\n        return this._emit('abort', error);\n      }\n      if (error instanceof OpenAIError) {\n        return this._emit('error', error);\n      }\n      if (error instanceof Error) {\n        const openAIError = new OpenAIError(error.message);\n        // @ts-ignore\n        openAIError.cause = error;\n        return this._emit('error', openAIError);\n      }\n      return this._emit('error', new OpenAIError(String(error)));\n    });\n    __classPrivateFieldSet(this, _AbstractChatCompletionRunner_connectedPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_resolveConnectedPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n    __classPrivateFieldSet(this, _AbstractChatCompletionRunner_endPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_resolveEndPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_rejectEndPromise, reject, \"f\");\n    }), \"f\");\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_connectedPromise, \"f\").catch(() => {});\n    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_endPromise, \"f\").catch(() => {});\n  }\n  _run(executor) {\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\n    // references to `this` before the `super()` constructor call returns.\n    setTimeout(() => {\n      executor().then(() => {\n        this._emitFinal();\n        this._emit('end');\n      }, __classPrivateFieldGet(this, _AbstractChatCompletionRunner_handleError, \"f\"));\n    }, 0);\n  }\n  _addChatCompletion(chatCompletion) {\n    var _chatCompletion$choic;\n    this._chatCompletions.push(chatCompletion);\n    this._emit('chatCompletion', chatCompletion);\n    const message = (_chatCompletion$choic = chatCompletion.choices[0]) === null || _chatCompletion$choic === void 0 ? void 0 : _chatCompletion$choic.message;\n    if (message) this._addMessage(message);\n    return chatCompletion;\n  }\n  _addMessage(message) {\n    let emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!('content' in message)) message.content = null;\n    this.messages.push(message);\n    if (emit) {\n      this._emit('message', message);\n      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {\n        // Note, this assumes that {role: 'tool', content: â€¦} is always the result of a call of tool of type=function.\n        this._emit('functionCallResult', message.content);\n      } else if (isAssistantMessage(message) && message.function_call) {\n        this._emit('functionCall', message.function_call);\n      } else if (isAssistantMessage(message) && message.tool_calls) {\n        for (const tool_call of message.tool_calls) {\n          if (tool_call.type === 'function') {\n            this._emit('functionCall', tool_call.function);\n          }\n        }\n      }\n    }\n  }\n  _connected() {\n    if (this.ended) return;\n    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_resolveConnectedPromise, \"f\").call(this);\n    this._emit('connect');\n  }\n  get ended() {\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_ended, \"f\");\n  }\n  get errored() {\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_errored, \"f\");\n  }\n  get aborted() {\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_aborted, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  on(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  off(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  once(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, \"f\");\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n  async done() {\n    __classPrivateFieldSet(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, \"f\");\n    await __classPrivateFieldGet(this, _AbstractChatCompletionRunner_endPromise, \"f\");\n  }\n  /**\n   * @returns a promise that resolves with the final ChatCompletion, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n   */\n  async finalChatCompletion() {\n    await this.done();\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (!completion) throw new OpenAIError('stream ended without producing a ChatCompletion');\n    return completion;\n  }\n  /**\n   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalContent() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalMessage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalFunctionCall() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n  }\n  async finalFunctionCallResult() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n  }\n  async totalUsage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);\n  }\n  allChatCompletions() {\n    return [...this._chatCompletions];\n  }\n  _emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // make sure we don't emit any events after end\n    if (__classPrivateFieldGet(this, _AbstractChatCompletionRunner_ended, \"f\")) {\n      return;\n    }\n    if (event === 'end') {\n      __classPrivateFieldSet(this, _AbstractChatCompletionRunner_ended, true, \"f\");\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_resolveEndPromise, \"f\").call(this);\n    }\n    const listeners = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event];\n    if (listeners) {\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(_ref => {\n        let {\n          listener\n        } = _ref;\n        return listener(...args);\n      });\n    }\n    if (event === 'abort') {\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _AbstractChatCompletionRunner_catchingPromiseCreated, \"f\") && !(listeners !== null && listeners !== void 0 && listeners.length)) {\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n      return;\n    }\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _AbstractChatCompletionRunner_catchingPromiseCreated, \"f\") && !(listeners !== null && listeners !== void 0 && listeners.length)) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.finalChatCompletion()\n        // - etc.\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _AbstractChatCompletionRunner_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n    }\n  }\n  _emitFinal() {\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (completion) this._emit('finalChatCompletion', completion);\n    const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n    if (finalMessage) this._emit('finalMessage', finalMessage);\n    const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n    if (finalContent) this._emit('finalContent', finalContent);\n    const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n    if (finalFunctionCall) this._emit('finalFunctionCall', finalFunctionCall);\n    const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n    if (finalFunctionCallResult != null) this._emit('finalFunctionCallResult', finalFunctionCallResult);\n    if (this._chatCompletions.some(c => c.usage)) {\n      this._emit('totalUsage', __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));\n    }\n  }\n  async _createChatCompletion(completions, params, options) {\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_validateParams).call(this, params);\n    const chatCompletion = await completions.create({\n      ...params,\n      stream: false\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    return this._addChatCompletion(chatCompletion);\n  }\n  async _runChatCompletion(completions, params, options) {\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    return await this._createChatCompletion(completions, params, options);\n  }\n  async _runFunctions(completions, params, options) {\n    const role = 'function';\n    const {\n      function_call = 'auto',\n      stream,\n      ...restParams\n    } = params;\n    const singleFunctionToCall = typeof function_call !== 'string' && (function_call === null || function_call === void 0 ? void 0 : function_call.name);\n    const {\n      maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS\n    } = options || {};\n    const functionsByName = {};\n    for (const f of params.functions) {\n      functionsByName[f.name || f.function.name] = f;\n    }\n    const functions = params.functions.map(f => ({\n      name: f.name || f.function.name,\n      parameters: f.parameters,\n      description: f.description\n    }));\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      var _chatCompletion$choic2;\n      const chatCompletion = await this._createChatCompletion(completions, {\n        ...restParams,\n        function_call,\n        functions,\n        messages: [...this.messages]\n      }, options);\n      const message = (_chatCompletion$choic2 = chatCompletion.choices[0]) === null || _chatCompletion$choic2 === void 0 ? void 0 : _chatCompletion$choic2.message;\n      if (!message) {\n        throw new OpenAIError(\"missing message in ChatCompletion response\");\n      }\n      if (!message.function_call) return;\n      const {\n        name,\n        arguments: args\n      } = message.function_call;\n      const fn = functionsByName[name];\n      if (!fn) {\n        const content = \"Invalid function_call: \".concat(JSON.stringify(name), \". Available options are: \").concat(functions.map(f => JSON.stringify(f.name)).join(', '), \". Please try again\");\n        this._addMessage({\n          role,\n          name,\n          content\n        });\n        continue;\n      } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n        const content = \"Invalid function_call: \".concat(JSON.stringify(name), \". \").concat(JSON.stringify(singleFunctionToCall), \" requested. Please try again\");\n        this._addMessage({\n          role,\n          name,\n          content\n        });\n        continue;\n      }\n      let parsed;\n      try {\n        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n      } catch (error) {\n        this._addMessage({\n          role,\n          name,\n          content: error instanceof Error ? error.message : String(error)\n        });\n        continue;\n      }\n      // @ts-expect-error it can't rule out `never` type.\n      const rawContent = await fn.function(parsed, this);\n      const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n      this._addMessage({\n        role,\n        name,\n        content\n      });\n      if (singleFunctionToCall) return;\n    }\n  }\n  async _runTools(completions, params, options) {\n    var _tool_choice$function;\n    const role = 'tool';\n    const {\n      tool_choice = 'auto',\n      stream,\n      ...restParams\n    } = params;\n    const singleFunctionToCall = typeof tool_choice !== 'string' && (tool_choice === null || tool_choice === void 0 || (_tool_choice$function = tool_choice.function) === null || _tool_choice$function === void 0 ? void 0 : _tool_choice$function.name);\n    const {\n      maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS\n    } = options || {};\n    const functionsByName = {};\n    for (const f of params.tools) {\n      if (f.type === 'function') {\n        functionsByName[f.function.name || f.function.function.name] = f.function;\n      }\n    }\n    const tools = 'tools' in params ? params.tools.map(t => t.type === 'function' ? {\n      type: 'function',\n      function: {\n        name: t.function.name || t.function.function.name,\n        parameters: t.function.parameters,\n        description: t.function.description\n      }\n    } : t) : undefined;\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      var _chatCompletion$choic3;\n      const chatCompletion = await this._createChatCompletion(completions, {\n        ...restParams,\n        tool_choice,\n        tools,\n        messages: [...this.messages]\n      }, options);\n      const message = (_chatCompletion$choic3 = chatCompletion.choices[0]) === null || _chatCompletion$choic3 === void 0 ? void 0 : _chatCompletion$choic3.message;\n      if (!message) {\n        throw new OpenAIError(\"missing message in ChatCompletion response\");\n      }\n      if (!message.tool_calls) {\n        return;\n      }\n      for (const tool_call of message.tool_calls) {\n        if (tool_call.type !== 'function') continue;\n        const tool_call_id = tool_call.id;\n        const {\n          name,\n          arguments: args\n        } = tool_call.function;\n        const fn = functionsByName[name];\n        if (!fn) {\n          const content = \"Invalid tool_call: \".concat(JSON.stringify(name), \". Available options are: \").concat(tools.map(f => JSON.stringify(f.function.name)).join(', '), \". Please try again\");\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n          continue;\n        } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n          const content = \"Invalid tool_call: \".concat(JSON.stringify(name), \". \").concat(JSON.stringify(singleFunctionToCall), \" requested. Please try again\");\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n          continue;\n        }\n        let parsed;\n        try {\n          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n        } catch (error) {\n          const content = error instanceof Error ? error.message : String(error);\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n          continue;\n        }\n        // @ts-expect-error it can't rule out `never` type.\n        const rawContent = await fn.function(parsed, this);\n        const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n        this._addMessage({\n          role,\n          tool_call_id,\n          content\n        });\n        if (singleFunctionToCall) {\n          return;\n        }\n      }\n    }\n    return;\n  }\n}\n_AbstractChatCompletionRunner_connectedPromise = new WeakMap(), _AbstractChatCompletionRunner_resolveConnectedPromise = new WeakMap(), _AbstractChatCompletionRunner_rejectConnectedPromise = new WeakMap(), _AbstractChatCompletionRunner_endPromise = new WeakMap(), _AbstractChatCompletionRunner_resolveEndPromise = new WeakMap(), _AbstractChatCompletionRunner_rejectEndPromise = new WeakMap(), _AbstractChatCompletionRunner_listeners = new WeakMap(), _AbstractChatCompletionRunner_ended = new WeakMap(), _AbstractChatCompletionRunner_errored = new WeakMap(), _AbstractChatCompletionRunner_aborted = new WeakMap(), _AbstractChatCompletionRunner_catchingPromiseCreated = new WeakMap(), _AbstractChatCompletionRunner_handleError = new WeakMap(), _AbstractChatCompletionRunner_instances = new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {\n  var _classPrivateFieldGe;\n  return (_classPrivateFieldGe = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this).content) !== null && _classPrivateFieldGe !== void 0 ? _classPrivateFieldGe : null;\n}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {\n  let i = this.messages.length;\n  while (i-- > 0) {\n    const message = this.messages[i];\n    if (isAssistantMessage(message)) {\n      var _message$content;\n      return {\n        ...message,\n        content: (_message$content = message.content) !== null && _message$content !== void 0 ? _message$content : null\n      };\n    }\n  }\n  throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall() {\n  for (let i = this.messages.length - 1; i >= 0; i--) {\n    var _message$tool_calls;\n    const message = this.messages[i];\n    if (isAssistantMessage(message) && message !== null && message !== void 0 && message.function_call) {\n      return message.function_call;\n    }\n    if (isAssistantMessage(message) && message !== null && message !== void 0 && (_message$tool_calls = message.tool_calls) !== null && _message$tool_calls !== void 0 && _message$tool_calls.length) {\n      var _message$tool_calls$a;\n      return (_message$tool_calls$a = message.tool_calls.at(-1)) === null || _message$tool_calls$a === void 0 ? void 0 : _message$tool_calls$a.function;\n    }\n  }\n  return;\n}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult() {\n  for (let i = this.messages.length - 1; i >= 0; i--) {\n    const message = this.messages[i];\n    if (isFunctionMessage(message) && message.content != null) {\n      return message.content;\n    }\n    if (isToolMessage(message) && message.content != null && this.messages.some(x => {\n      var _x$tool_calls;\n      return x.role === 'assistant' && ((_x$tool_calls = x.tool_calls) === null || _x$tool_calls === void 0 ? void 0 : _x$tool_calls.some(y => y.type === 'function' && y.id === message.tool_call_id));\n    })) {\n      return message.content;\n    }\n  }\n  return;\n}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {\n  const total = {\n    completion_tokens: 0,\n    prompt_tokens: 0,\n    total_tokens: 0\n  };\n  for (const {\n    usage\n  } of this._chatCompletions) {\n    if (usage) {\n      total.completion_tokens += usage.completion_tokens;\n      total.prompt_tokens += usage.prompt_tokens;\n      total.total_tokens += usage.total_tokens;\n    }\n  }\n  return total;\n}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {\n  if (params.n != null && params.n > 1) {\n    throw new OpenAIError('ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.');\n  }\n}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {\n  return typeof rawContent === 'string' ? rawContent : rawContent === undefined ? 'undefined' : JSON.stringify(rawContent);\n};","map":{"version":3,"names":["APIUserAbortError","OpenAIError","isRunnableFunctionWithParse","isAssistantMessage","isFunctionMessage","isToolMessage","DEFAULT_MAX_CHAT_COMPLETIONS","AbstractChatCompletionRunner","constructor","controller","AbortController","_AbstractChatCompletionRunner_connectedPromise","set","_AbstractChatCompletionRunner_resolveConnectedPromise","_AbstractChatCompletionRunner_rejectConnectedPromise","_AbstractChatCompletionRunner_endPromise","_AbstractChatCompletionRunner_resolveEndPromise","_AbstractChatCompletionRunner_rejectEndPromise","_AbstractChatCompletionRunner_listeners","_chatCompletions","messages","_AbstractChatCompletionRunner_ended","_AbstractChatCompletionRunner_errored","_AbstractChatCompletionRunner_aborted","_AbstractChatCompletionRunner_catchingPromiseCreated","_AbstractChatCompletionRunner_handleError","error","__classPrivateFieldSet","Error","name","_emit","openAIError","message","cause","String","Promise","resolve","reject","__classPrivateFieldGet","catch","_run","executor","setTimeout","then","_emitFinal","_addChatCompletion","chatCompletion","_chatCompletion$choic","push","choices","_addMessage","emit","arguments","length","undefined","content","function_call","tool_calls","tool_call","type","function","_connected","ended","call","errored","aborted","abort","on","event","listener","listeners","off","index","findIndex","l","splice","once","emitted","done","finalChatCompletion","completion","finalContent","_AbstractChatCompletionRunner_instances","_AbstractChatCompletionRunner_getFinalContent","finalMessage","_AbstractChatCompletionRunner_getFinalMessage","finalFunctionCall","_AbstractChatCompletionRunner_getFinalFunctionCall","finalFunctionCallResult","_AbstractChatCompletionRunner_getFinalFunctionCallResult","totalUsage","_AbstractChatCompletionRunner_calculateTotalUsage","allChatCompletions","_len","args","Array","_key","filter","forEach","_ref","some","c","usage","_createChatCompletion","completions","params","options","signal","addEventListener","_AbstractChatCompletionRunner_validateParams","create","stream","_runChatCompletion","_runFunctions","role","restParams","singleFunctionToCall","maxChatCompletions","functionsByName","f","functions","map","parameters","description","i","_chatCompletion$choic2","fn","concat","JSON","stringify","join","parsed","parse","rawContent","_AbstractChatCompletionRunner_stringifyFunctionCallResult","_runTools","_tool_choice$function","tool_choice","tools","t","_chatCompletion$choic3","tool_call_id","id","_classPrivateFieldGe","_message$content","_message$tool_calls","_message$tool_calls$a","at","x","_x$tool_calls","y","total","completion_tokens","prompt_tokens","total_tokens","n"],"sources":["/Users/SammyD/Desktop/Trivia-Forge/trivia-forge/node_modules/openai/src/lib/AbstractChatCompletionRunner.ts"],"sourcesContent":["import * as Core from \"../core\";\nimport { type CompletionUsage } from \"../resources/completions\";\nimport {\n  type Completions,\n  type ChatCompletion,\n  type ChatCompletionMessage,\n  type ChatCompletionMessageParam,\n  type ChatCompletionCreateParams,\n  type ChatCompletionTool,\n} from \"../resources/chat/completions\";\nimport { APIUserAbortError, OpenAIError } from \"../error\";\nimport {\n  type RunnableFunction,\n  isRunnableFunctionWithParse,\n  type BaseFunctionsArgs,\n} from './RunnableFunction';\nimport { ChatCompletionFunctionRunnerParams, ChatCompletionToolRunnerParams } from './ChatCompletionRunner';\nimport {\n  ChatCompletionStreamingFunctionRunnerParams,\n  ChatCompletionStreamingToolRunnerParams,\n} from './ChatCompletionStreamingRunner';\nimport { isAssistantMessage, isFunctionMessage, isToolMessage } from './chatCompletionUtils';\n\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nexport interface RunnerOptions extends Core.RequestOptions {\n  /** How many requests to make before canceling. Default 10. */\n  maxChatCompletions?: number;\n}\n\nexport abstract class AbstractChatCompletionRunner<\n  Events extends CustomEvents<any> = AbstractChatCompletionRunnerEvents,\n> {\n  controller: AbortController = new AbortController();\n\n  #connectedPromise: Promise<void>;\n  #resolveConnectedPromise: () => void = () => {};\n  #rejectConnectedPromise: (error: OpenAIError) => void = () => {};\n\n  #endPromise: Promise<void>;\n  #resolveEndPromise: () => void = () => {};\n  #rejectEndPromise: (error: OpenAIError) => void = () => {};\n\n  #listeners: { [Event in keyof Events]?: ListenersForEvent<Events, Event> } = {};\n\n  protected _chatCompletions: ChatCompletion[] = [];\n  messages: ChatCompletionMessageParam[] = [];\n\n  #ended = false;\n  #errored = false;\n  #aborted = false;\n  #catchingPromiseCreated = false;\n\n  constructor() {\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveConnectedPromise = resolve;\n      this.#rejectConnectedPromise = reject;\n    });\n\n    this.#endPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveEndPromise = resolve;\n      this.#rejectEndPromise = reject;\n    });\n\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    this.#connectedPromise.catch(() => {});\n    this.#endPromise.catch(() => {});\n  }\n\n  protected _run(executor: () => Promise<any>) {\n    // Unfortunately if we call `executor()` immediately we get runtime errors about\n    // references to `this` before the `super()` constructor call returns.\n    setTimeout(() => {\n      executor().then(() => {\n        this._emitFinal();\n        this._emit('end');\n      }, this.#handleError);\n    }, 0);\n  }\n\n  protected _addChatCompletion(chatCompletion: ChatCompletion): ChatCompletion {\n    this._chatCompletions.push(chatCompletion);\n    this._emit('chatCompletion', chatCompletion);\n    const message = chatCompletion.choices[0]?.message;\n    if (message) this._addMessage(message as ChatCompletionMessageParam);\n    return chatCompletion;\n  }\n\n  protected _addMessage(message: ChatCompletionMessageParam, emit = true) {\n    if (!('content' in message)) message.content = null;\n\n    this.messages.push(message);\n\n    if (emit) {\n      this._emit('message', message);\n      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {\n        // Note, this assumes that {role: 'tool', content: â€¦} is always the result of a call of tool of type=function.\n        this._emit('functionCallResult', message.content as string);\n      } else if (isAssistantMessage(message) && message.function_call) {\n        this._emit('functionCall', message.function_call);\n      } else if (isAssistantMessage(message) && message.tool_calls) {\n        for (const tool_call of message.tool_calls) {\n          if (tool_call.type === 'function') {\n            this._emit('functionCall', tool_call.function);\n          }\n        }\n      }\n    }\n  }\n\n  protected _connected() {\n    if (this.ended) return;\n    this.#resolveConnectedPromise();\n    this._emit('connect');\n  }\n\n  get ended(): boolean {\n    return this.#ended;\n  }\n\n  get errored(): boolean {\n    return this.#errored;\n  }\n\n  get aborted(): boolean {\n    return this.#aborted;\n  }\n\n  abort() {\n    this.controller.abort();\n  }\n\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  on<Event extends keyof Events>(event: Event, listener: ListenerForEvent<Events, Event>): this {\n    const listeners: ListenersForEvent<Events, Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener });\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  off<Event extends keyof Events>(event: Event, listener: ListenerForEvent<Events, Event>): this {\n    const listeners = this.#listeners[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex((l) => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this ChatCompletionStream, so that calls can be chained\n   */\n  once<Event extends keyof Events>(event: Event, listener: ListenerForEvent<Events, Event>): this {\n    const listeners: ListenersForEvent<Events, Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener, once: true });\n    return this;\n  }\n\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted<Event extends keyof Events>(\n    event: Event,\n  ): Promise<\n    EventParameters<Events, Event> extends [infer Param] ? Param\n    : EventParameters<Events, Event> extends [] ? void\n    : EventParameters<Events, Event>\n  > {\n    return new Promise((resolve, reject) => {\n      this.#catchingPromiseCreated = true;\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve as any);\n    });\n  }\n\n  async done(): Promise<void> {\n    this.#catchingPromiseCreated = true;\n    await this.#endPromise;\n  }\n\n  /**\n   * @returns a promise that resolves with the final ChatCompletion, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n   */\n  async finalChatCompletion(): Promise<ChatCompletion> {\n    await this.done();\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (!completion) throw new OpenAIError('stream ended without producing a ChatCompletion');\n    return completion;\n  }\n\n  #getFinalContent(): string | null {\n    return this.#getFinalMessage().content ?? null;\n  }\n\n  /**\n   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalContent(): Promise<string | null> {\n    await this.done();\n    return this.#getFinalContent();\n  }\n\n  #getFinalMessage(): ChatCompletionMessage {\n    let i = this.messages.length;\n    while (i-- > 0) {\n      const message = this.messages[i];\n      if (isAssistantMessage(message)) {\n        return { ...message, content: message.content ?? null };\n      }\n    }\n    throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalMessage(): Promise<ChatCompletionMessage> {\n    await this.done();\n    return this.#getFinalMessage();\n  }\n\n  #getFinalFunctionCall(): ChatCompletionMessage.FunctionCall | undefined {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n      const message = this.messages[i];\n      if (isAssistantMessage(message) && message?.function_call) {\n        return message.function_call;\n      }\n      if (isAssistantMessage(message) && message?.tool_calls?.length) {\n        return message.tool_calls.at(-1)?.function;\n      }\n    }\n\n    return;\n  }\n\n  /**\n   * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalFunctionCall(): Promise<ChatCompletionMessage.FunctionCall | undefined> {\n    await this.done();\n    return this.#getFinalFunctionCall();\n  }\n\n  #getFinalFunctionCallResult(): string | undefined {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n      const message = this.messages[i];\n      if (isFunctionMessage(message) && message.content != null) {\n        return message.content;\n      }\n      if (\n        isToolMessage(message) &&\n        message.content != null &&\n        this.messages.some(\n          (x) =>\n            x.role === 'assistant' &&\n            x.tool_calls?.some((y) => y.type === 'function' && y.id === message.tool_call_id),\n        )\n      ) {\n        return message.content;\n      }\n    }\n\n    return;\n  }\n\n  async finalFunctionCallResult(): Promise<string | undefined> {\n    await this.done();\n    return this.#getFinalFunctionCallResult();\n  }\n\n  #calculateTotalUsage(): CompletionUsage {\n    const total: CompletionUsage = {\n      completion_tokens: 0,\n      prompt_tokens: 0,\n      total_tokens: 0,\n    };\n    for (const { usage } of this._chatCompletions) {\n      if (usage) {\n        total.completion_tokens += usage.completion_tokens;\n        total.prompt_tokens += usage.prompt_tokens;\n        total.total_tokens += usage.total_tokens;\n      }\n    }\n    return total;\n  }\n\n  async totalUsage(): Promise<CompletionUsage> {\n    await this.done();\n    return this.#calculateTotalUsage();\n  }\n\n  allChatCompletions(): ChatCompletion[] {\n    return [...this._chatCompletions];\n  }\n\n  #handleError = (error: unknown) => {\n    this.#errored = true;\n    if (error instanceof Error && error.name === 'AbortError') {\n      error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n      this.#aborted = true;\n      return this._emit('abort', error);\n    }\n    if (error instanceof OpenAIError) {\n      return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n      const openAIError: OpenAIError = new OpenAIError(error.message);\n      // @ts-ignore\n      openAIError.cause = error;\n      return this._emit('error', openAIError);\n    }\n    return this._emit('error', new OpenAIError(String(error)));\n  };\n\n  protected _emit<Event extends keyof Events>(event: Event, ...args: EventParameters<Events, Event>) {\n    // make sure we don't emit any events after end\n    if (this.#ended) {\n      return;\n    }\n\n    if (event === 'end') {\n      this.#ended = true;\n      this.#resolveEndPromise();\n    }\n\n    const listeners: ListenersForEvent<Events, Event> | undefined = this.#listeners[event];\n    if (listeners) {\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\n      listeners.forEach(({ listener }: any) => listener(...args));\n    }\n\n    if (event === 'abort') {\n      const error = args[0] as APIUserAbortError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n      return;\n    }\n\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n\n      const error = args[0] as OpenAIError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.finalChatCompletion()\n        // - etc.\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n    }\n  }\n\n  protected _emitFinal() {\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (completion) this._emit('finalChatCompletion', completion);\n    const finalMessage = this.#getFinalMessage();\n    if (finalMessage) this._emit('finalMessage', finalMessage);\n    const finalContent = this.#getFinalContent();\n    if (finalContent) this._emit('finalContent', finalContent);\n\n    const finalFunctionCall = this.#getFinalFunctionCall();\n    if (finalFunctionCall) this._emit('finalFunctionCall', finalFunctionCall);\n\n    const finalFunctionCallResult = this.#getFinalFunctionCallResult();\n    if (finalFunctionCallResult != null) this._emit('finalFunctionCallResult', finalFunctionCallResult);\n\n    if (this._chatCompletions.some((c) => c.usage)) {\n      this._emit('totalUsage', this.#calculateTotalUsage());\n    }\n  }\n\n  #validateParams(params: ChatCompletionCreateParams): void {\n    if (params.n != null && params.n > 1) {\n      throw new OpenAIError(\n        'ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.',\n      );\n    }\n  }\n\n  protected async _createChatCompletion(\n    completions: Completions,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#validateParams(params);\n\n    const chatCompletion = await completions.create(\n      { ...params, stream: false },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    return this._addChatCompletion(chatCompletion);\n  }\n\n  protected async _runChatCompletion(\n    completions: Completions,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    return await this._createChatCompletion(completions, params, options);\n  }\n\n  protected async _runFunctions<FunctionsArgs extends BaseFunctionsArgs>(\n    completions: Completions,\n    params:\n      | ChatCompletionFunctionRunnerParams<FunctionsArgs>\n      | ChatCompletionStreamingFunctionRunnerParams<FunctionsArgs>,\n    options?: RunnerOptions,\n  ) {\n    const role = 'function' as const;\n    const { function_call = 'auto', stream, ...restParams } = params;\n    const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;\n    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n\n    const functionsByName: Record<string, RunnableFunction<any>> = {};\n    for (const f of params.functions) {\n      functionsByName[f.name || f.function.name] = f;\n    }\n\n    const functions: ChatCompletionCreateParams.Function[] = params.functions.map(\n      (f): ChatCompletionCreateParams.Function => ({\n        name: f.name || f.function.name,\n        parameters: f.parameters as Record<string, unknown>,\n        description: f.description,\n      }),\n    );\n\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion: ChatCompletion = await this._createChatCompletion(\n        completions,\n        {\n          ...restParams,\n          function_call,\n          functions,\n          messages: [...this.messages],\n        },\n        options,\n      );\n      const message = chatCompletion.choices[0]?.message;\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n      if (!message.function_call) return;\n      const { name, arguments: args } = message.function_call;\n      const fn = functionsByName[name];\n      if (!fn) {\n        const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions\n          .map((f) => JSON.stringify(f.name))\n          .join(', ')}. Please try again`;\n\n        this._addMessage({ role, name, content });\n        continue;\n      } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n        const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(\n          singleFunctionToCall,\n        )} requested. Please try again`;\n\n        this._addMessage({ role, name, content });\n        continue;\n      }\n\n      let parsed;\n      try {\n        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n      } catch (error) {\n        this._addMessage({\n          role,\n          name,\n          content: error instanceof Error ? error.message : String(error),\n        });\n        continue;\n      }\n\n      // @ts-expect-error it can't rule out `never` type.\n      const rawContent = await fn.function(parsed, this);\n      const content = this.#stringifyFunctionCallResult(rawContent);\n\n      this._addMessage({ role, name, content });\n\n      if (singleFunctionToCall) return;\n    }\n  }\n\n  protected async _runTools<FunctionsArgs extends BaseFunctionsArgs>(\n    completions: Completions,\n    params:\n      | ChatCompletionToolRunnerParams<FunctionsArgs>\n      | ChatCompletionStreamingToolRunnerParams<FunctionsArgs>,\n    options?: RunnerOptions,\n  ) {\n    const role = 'tool' as const;\n    const { tool_choice = 'auto', stream, ...restParams } = params;\n    const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n\n    const functionsByName: Record<string, RunnableFunction<any>> = {};\n    for (const f of params.tools) {\n      if (f.type === 'function') {\n        functionsByName[f.function.name || f.function.function.name] = f.function;\n      }\n    }\n\n    const tools: ChatCompletionTool[] =\n      'tools' in params ?\n        params.tools.map((t) =>\n          t.type === 'function' ?\n            {\n              type: 'function',\n              function: {\n                name: t.function.name || t.function.function.name,\n                parameters: t.function.parameters as Record<string, unknown>,\n                description: t.function.description,\n              },\n            }\n          : (t as unknown as ChatCompletionTool),\n        )\n      : (undefined as any);\n\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion: ChatCompletion = await this._createChatCompletion(\n        completions,\n        {\n          ...restParams,\n          tool_choice,\n          tools,\n          messages: [...this.messages],\n        },\n        options,\n      );\n      const message = chatCompletion.choices[0]?.message;\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n      if (!message.tool_calls) {\n        return;\n      }\n\n      for (const tool_call of message.tool_calls) {\n        if (tool_call.type !== 'function') continue;\n        const tool_call_id = tool_call.id;\n        const { name, arguments: args } = tool_call.function;\n        const fn = functionsByName[name];\n\n        if (!fn) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${tools\n            .map((f) => JSON.stringify(f.function.name))\n            .join(', ')}. Please try again`;\n\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(\n            singleFunctionToCall,\n          )} requested. Please try again`;\n\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        }\n\n        let parsed;\n        try {\n          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n        } catch (error) {\n          const content = error instanceof Error ? error.message : String(error);\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        }\n\n        // @ts-expect-error it can't rule out `never` type.\n        const rawContent = await fn.function(parsed, this);\n        const content = this.#stringifyFunctionCallResult(rawContent);\n        this._addMessage({ role, tool_call_id, content });\n\n        if (singleFunctionToCall) {\n          return;\n        }\n      }\n    }\n\n    return;\n  }\n\n  #stringifyFunctionCallResult(rawContent: unknown): string {\n    return (\n      typeof rawContent === 'string' ? rawContent\n      : rawContent === undefined ? 'undefined'\n      : JSON.stringify(rawContent)\n    );\n  }\n}\n\ntype CustomEvents<Event extends string> = {\n  [k in Event]: k extends keyof AbstractChatCompletionRunnerEvents ? AbstractChatCompletionRunnerEvents[k]\n  : (...args: any[]) => void;\n};\n\ntype ListenerForEvent<Events extends CustomEvents<any>, Event extends keyof Events> = Event extends (\n  keyof AbstractChatCompletionRunnerEvents\n) ?\n  AbstractChatCompletionRunnerEvents[Event]\n: Events[Event];\n\ntype ListenersForEvent<Events extends CustomEvents<any>, Event extends keyof Events> = Array<{\n  listener: ListenerForEvent<Events, Event>;\n  once?: boolean;\n}>;\ntype EventParameters<Events extends CustomEvents<any>, Event extends keyof Events> = Parameters<\n  ListenerForEvent<Events, Event>\n>;\n\nexport interface AbstractChatCompletionRunnerEvents {\n  connect: () => void;\n  functionCall: (functionCall: ChatCompletionMessage.FunctionCall) => void;\n  message: (message: ChatCompletionMessageParam) => void;\n  chatCompletion: (completion: ChatCompletion) => void;\n  finalContent: (contentSnapshot: string) => void;\n  finalMessage: (message: ChatCompletionMessageParam) => void;\n  finalChatCompletion: (completion: ChatCompletion) => void;\n  finalFunctionCall: (functionCall: ChatCompletionMessage.FunctionCall) => void;\n  functionCallResult: (content: string) => void;\n  finalFunctionCallResult: (content: string) => void;\n  error: (error: OpenAIError) => void;\n  abort: (error: APIUserAbortError) => void;\n  end: () => void;\n  totalUsage: (usage: CompletionUsage) => void;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
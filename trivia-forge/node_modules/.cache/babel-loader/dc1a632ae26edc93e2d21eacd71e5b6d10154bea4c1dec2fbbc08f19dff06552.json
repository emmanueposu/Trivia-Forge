{"ast":null,"code":"var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _ChatCompletionStream_instances, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_addChunk, _ChatCompletionStream_endRequest, _ChatCompletionStream_accumulateChatCompletion;\nimport { OpenAIError, APIUserAbortError } from 'openai/error';\nimport { AbstractChatCompletionRunner } from \"./AbstractChatCompletionRunner.mjs\";\nimport { Stream } from 'openai/streaming';\nexport class ChatCompletionStream extends AbstractChatCompletionRunner {\n  constructor() {\n    super(...arguments);\n    _ChatCompletionStream_instances.add(this);\n    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n  }\n  get currentChatCompletionSnapshot() {\n    return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n  }\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream) {\n    const runner = new ChatCompletionStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n  static createChatCompletion(completions, params, options) {\n    const runner = new ChatCompletionStream();\n    runner._run(() => runner._runChatCompletion(completions, {\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      headers: {\n        ...(options === null || options === void 0 ? void 0 : options.headers),\n        'X-Stainless-Helper-Method': 'stream'\n      }\n    }));\n    return runner;\n  }\n  async _createChatCompletion(completions, params, options) {\n    var _stream$controller$si;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n    const stream = await completions.create({\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    for await (const chunk of stream) {\n      __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n    }\n    if ((_stream$controller$si = stream.controller.signal) !== null && _stream$controller$si !== void 0 && _stream$controller$si.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n  }\n  async _fromReadableStream(readableStream, options) {\n    var _stream$controller$si2;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n    this._connected();\n    const stream = Stream.fromReadableStream(readableStream, this.controller);\n    let chatId;\n    for await (const chunk of stream) {\n      if (chatId && chatId !== chunk.id) {\n        // A new request has been made.\n        this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n      }\n      __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n      chatId = chunk.id;\n    }\n    if ((_stream$controller$si2 = stream.controller.signal) !== null && _stream$controller$si2 !== void 0 && _stream$controller$si2.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n  }\n  [(_ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n    var _chunk$choices$, _completion$choices$;\n    if (this.ended) return;\n    const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n    this._emit('chunk', chunk, completion);\n    const delta = (_chunk$choices$ = chunk.choices[0]) === null || _chunk$choices$ === void 0 || (_chunk$choices$ = _chunk$choices$.delta) === null || _chunk$choices$ === void 0 ? void 0 : _chunk$choices$.content;\n    const snapshot = (_completion$choices$ = completion.choices[0]) === null || _completion$choices$ === void 0 ? void 0 : _completion$choices$.message;\n    if (delta != null && (snapshot === null || snapshot === void 0 ? void 0 : snapshot.role) === 'assistant' && snapshot !== null && snapshot !== void 0 && snapshot.content) {\n      this._emit('content', delta, snapshot.content);\n    }\n  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n    if (this.ended) {\n      throw new OpenAIError(\"stream has ended, this shouldn't happen\");\n    }\n    const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    if (!snapshot) {\n      throw new OpenAIError(\"request ended without sending any chunks\");\n    }\n    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n    return finalizeChatCompletion(snapshot);\n  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n    var _a, _b, _c;\n    let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    const {\n      choices,\n      ...rest\n    } = chunk;\n    if (!snapshot) {\n      snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {\n        ...rest,\n        choices: []\n      }, \"f\");\n    } else {\n      Object.assign(snapshot, rest);\n    }\n    for (const {\n      delta,\n      finish_reason,\n      index,\n      logprobs = null,\n      ...other\n    } of chunk.choices) {\n      let choice = snapshot.choices[index];\n      if (!choice) {\n        choice = snapshot.choices[index] = {\n          finish_reason,\n          index,\n          message: {},\n          logprobs,\n          ...other\n        };\n      }\n      if (logprobs) {\n        if (!choice.logprobs) {\n          choice.logprobs = Object.assign({}, logprobs);\n        } else {\n          const {\n            content,\n            ...rest\n          } = logprobs;\n          Object.assign(choice.logprobs, rest);\n          if (content) {\n            var _a$content;\n            (_a$content = (_a = choice.logprobs).content) !== null && _a$content !== void 0 ? _a$content : _a.content = [];\n            choice.logprobs.content.push(...content);\n          }\n        }\n      }\n      if (finish_reason) choice.finish_reason = finish_reason;\n      Object.assign(choice, other);\n      if (!delta) continue; // Shouldn't happen; just in case.\n      const {\n        content,\n        function_call,\n        role,\n        tool_calls,\n        ...rest\n      } = delta;\n      Object.assign(choice.message, rest);\n      if (content) choice.message.content = (choice.message.content || '') + content;\n      if (role) choice.message.role = role;\n      if (function_call) {\n        if (!choice.message.function_call) {\n          choice.message.function_call = function_call;\n        } else {\n          if (function_call.name) choice.message.function_call.name = function_call.name;\n          if (function_call.arguments) {\n            var _b$arguments;\n            (_b$arguments = (_b = choice.message.function_call).arguments) !== null && _b$arguments !== void 0 ? _b$arguments : _b.arguments = '';\n            choice.message.function_call.arguments += function_call.arguments;\n          }\n        }\n      }\n      if (tool_calls) {\n        if (!choice.message.tool_calls) choice.message.tool_calls = [];\n        for (const {\n          index,\n          id,\n          type,\n          function: fn,\n          ...rest\n        } of tool_calls) {\n          var _c$index, _tool_call$function;\n          const tool_call = (_c$index = (_c = choice.message.tool_calls)[index]) !== null && _c$index !== void 0 ? _c$index : _c[index] = {};\n          Object.assign(tool_call, rest);\n          if (id) tool_call.id = id;\n          if (type) tool_call.type = type;\n          if (fn) (_tool_call$function = tool_call.function) !== null && _tool_call$function !== void 0 ? _tool_call$function : tool_call.function = {\n            arguments: ''\n          };\n          if (fn !== null && fn !== void 0 && fn.name) tool_call.function.name = fn.name;\n          if (fn !== null && fn !== void 0 && fn.arguments) tool_call.function.arguments += fn.arguments;\n        }\n      }\n    }\n    return snapshot;\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('chunk', chunk => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  toReadableStream() {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\nfunction finalizeChatCompletion(snapshot) {\n  const {\n    id,\n    choices,\n    created,\n    model,\n    system_fingerprint,\n    ...rest\n  } = snapshot;\n  return {\n    ...rest,\n    id,\n    choices: choices.map(_ref => {\n      let {\n        message,\n        finish_reason,\n        index,\n        logprobs,\n        ...choiceRest\n      } = _ref;\n      if (!finish_reason) throw new OpenAIError(\"missing finish_reason for choice \".concat(index));\n      const {\n        content = null,\n        function_call,\n        tool_calls,\n        ...messageRest\n      } = message;\n      const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n      if (!role) throw new OpenAIError(\"missing role for choice \".concat(index));\n      if (function_call) {\n        const {\n          arguments: args,\n          name\n        } = function_call;\n        if (args == null) throw new OpenAIError(\"missing function_call.arguments for choice \".concat(index));\n        if (!name) throw new OpenAIError(\"missing function_call.name for choice \".concat(index));\n        return {\n          ...choiceRest,\n          message: {\n            content,\n            function_call: {\n              arguments: args,\n              name\n            },\n            role\n          },\n          finish_reason,\n          index,\n          logprobs\n        };\n      }\n      if (tool_calls) {\n        return {\n          ...choiceRest,\n          index,\n          finish_reason,\n          logprobs,\n          message: {\n            ...messageRest,\n            role,\n            content,\n            tool_calls: tool_calls.map((tool_call, i) => {\n              const {\n                function: fn,\n                type,\n                id,\n                ...toolRest\n              } = tool_call;\n              const {\n                arguments: args,\n                name,\n                ...fnRest\n              } = fn || {};\n              if (id == null) throw new OpenAIError(\"missing choices[\".concat(index, \"].tool_calls[\").concat(i, \"].id\\n\").concat(str(snapshot)));\n              if (type == null) throw new OpenAIError(\"missing choices[\".concat(index, \"].tool_calls[\").concat(i, \"].type\\n\").concat(str(snapshot)));\n              if (name == null) throw new OpenAIError(\"missing choices[\".concat(index, \"].tool_calls[\").concat(i, \"].function.name\\n\").concat(str(snapshot)));\n              if (args == null) throw new OpenAIError(\"missing choices[\".concat(index, \"].tool_calls[\").concat(i, \"].function.arguments\\n\").concat(str(snapshot)));\n              return {\n                ...toolRest,\n                id,\n                type,\n                function: {\n                  ...fnRest,\n                  name,\n                  arguments: args\n                }\n              };\n            })\n          }\n        };\n      }\n      return {\n        ...choiceRest,\n        message: {\n          ...messageRest,\n          content,\n          role\n        },\n        finish_reason,\n        index,\n        logprobs\n      };\n    }),\n    created,\n    model,\n    object: 'chat.completion',\n    ...(system_fingerprint ? {\n      system_fingerprint\n    } : {})\n  };\n}\nfunction str(x) {\n  return JSON.stringify(x);\n}","map":{"version":3,"names":["OpenAIError","APIUserAbortError","AbstractChatCompletionRunner","Stream","ChatCompletionStream","constructor","_ChatCompletionStream_currentChatCompletionSnapshot","set","currentChatCompletionSnapshot","__classPrivateFieldGet","fromReadableStream","stream","runner","_run","_fromReadableStream","createChatCompletion","completions","params","options","_runChatCompletion","headers","_createChatCompletion","_stream$controller$si","signal","aborted","controller","abort","addEventListener","_ChatCompletionStream_instances","_ChatCompletionStream_beginRequest","call","create","_connected","chunk","_ChatCompletionStream_addChunk","_addChatCompletion","_ChatCompletionStream_endRequest","readableStream","_stream$controller$si2","chatId","id","WeakMap","WeakSet","ended","__classPrivateFieldSet","undefined","_chunk$choices$","_completion$choices$","completion","_ChatCompletionStream_accumulateChatCompletion","_emit","delta","choices","content","snapshot","message","role","finalizeChatCompletion","rest","Object","assign","finish_reason","index","logprobs","other","choice","_a$content","_a","push","function_call","tool_calls","name","arguments","_b$arguments","_b","type","function","fn","_c$index","_tool_call$function","tool_call","_c","Symbol","asyncIterator","pushQueue","readQueue","done","on","reader","shift","resolve","length","err","reject","next","value","Promise","then","return","toReadableStream","bind","created","model","system_fingerprint","map","_ref","choiceRest","concat","messageRest","args","i","toolRest","fnRest","str","object","x","JSON","stringify"],"sources":["/Users/SammyD/Desktop/Trivia-Forge/trivia-forge/node_modules/openai/src/lib/ChatCompletionStream.ts"],"sourcesContent":["import * as Core from \"../core\";\nimport { OpenAIError, APIUserAbortError } from \"../error\";\nimport {\n  Completions,\n  type ChatCompletion,\n  type ChatCompletionChunk,\n  type ChatCompletionCreateParams,\n  type ChatCompletionCreateParamsBase,\n} from \"../resources/chat/completions\";\nimport {\n  AbstractChatCompletionRunner,\n  type AbstractChatCompletionRunnerEvents,\n} from './AbstractChatCompletionRunner';\nimport { type ReadableStream } from \"../_shims/index\";\nimport { Stream } from \"../streaming\";\n\nexport interface ChatCompletionStreamEvents extends AbstractChatCompletionRunnerEvents {\n  content: (contentDelta: string, contentSnapshot: string) => void;\n  chunk: (chunk: ChatCompletionChunk, snapshot: ChatCompletionSnapshot) => void;\n}\n\nexport type ChatCompletionStreamParams = Omit<ChatCompletionCreateParamsBase, 'stream'> & {\n  stream?: true;\n};\n\nexport class ChatCompletionStream\n  extends AbstractChatCompletionRunner<ChatCompletionStreamEvents>\n  implements AsyncIterable<ChatCompletionChunk>\n{\n  #currentChatCompletionSnapshot: ChatCompletionSnapshot | undefined;\n\n  get currentChatCompletionSnapshot(): ChatCompletionSnapshot | undefined {\n    return this.#currentChatCompletionSnapshot;\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): ChatCompletionStream {\n    const runner = new ChatCompletionStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createChatCompletion(\n    completions: Completions,\n    params: ChatCompletionStreamParams,\n    options?: Core.RequestOptions,\n  ): ChatCompletionStream {\n    const runner = new ChatCompletionStream();\n    runner._run(() =>\n      runner._runChatCompletion(\n        completions,\n        { ...params, stream: true },\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\n      ),\n    );\n    return runner;\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentChatCompletionSnapshot = undefined;\n  }\n  #addChunk(chunk: ChatCompletionChunk) {\n    if (this.ended) return;\n    const completion = this.#accumulateChatCompletion(chunk);\n    this._emit('chunk', chunk, completion);\n    const delta = chunk.choices[0]?.delta?.content;\n    const snapshot = completion.choices[0]?.message;\n    if (delta != null && snapshot?.role === 'assistant' && snapshot?.content) {\n      this._emit('content', delta, snapshot.content);\n    }\n  }\n  #endRequest(): ChatCompletion {\n    if (this.ended) {\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentChatCompletionSnapshot;\n    if (!snapshot) {\n      throw new OpenAIError(`request ended without sending any chunks`);\n    }\n    this.#currentChatCompletionSnapshot = undefined;\n    return finalizeChatCompletion(snapshot);\n  }\n\n  protected override async _createChatCompletion(\n    completions: Completions,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    const stream = await completions.create(\n      { ...params, stream: true },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    for await (const chunk of stream) {\n      this.#addChunk(chunk);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected();\n    const stream = Stream.fromReadableStream<ChatCompletionChunk>(readableStream, this.controller);\n    let chatId;\n    for await (const chunk of stream) {\n      if (chatId && chatId !== chunk.id) {\n        // A new request has been made.\n        this._addChatCompletion(this.#endRequest());\n      }\n\n      this.#addChunk(chunk);\n      chatId = chunk.id;\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  #accumulateChatCompletion(chunk: ChatCompletionChunk): ChatCompletionSnapshot {\n    let snapshot = this.#currentChatCompletionSnapshot;\n    const { choices, ...rest } = chunk;\n    if (!snapshot) {\n      snapshot = this.#currentChatCompletionSnapshot = {\n        ...rest,\n        choices: [],\n      };\n    } else {\n      Object.assign(snapshot, rest);\n    }\n\n    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\n      let choice = snapshot.choices[index];\n      if (!choice) {\n        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };\n      }\n\n      if (logprobs) {\n        if (!choice.logprobs) {\n          choice.logprobs = Object.assign({}, logprobs);\n        } else {\n          const { content, ...rest } = logprobs;\n          Object.assign(choice.logprobs, rest);\n          if (content) {\n            choice.logprobs.content ??= [];\n            choice.logprobs.content.push(...content);\n          }\n        }\n      }\n\n      if (finish_reason) choice.finish_reason = finish_reason;\n      Object.assign(choice, other);\n\n      if (!delta) continue; // Shouldn't happen; just in case.\n      const { content, function_call, role, tool_calls, ...rest } = delta;\n      Object.assign(choice.message, rest);\n\n      if (content) choice.message.content = (choice.message.content || '') + content;\n      if (role) choice.message.role = role;\n      if (function_call) {\n        if (!choice.message.function_call) {\n          choice.message.function_call = function_call;\n        } else {\n          if (function_call.name) choice.message.function_call.name = function_call.name;\n          if (function_call.arguments) {\n            choice.message.function_call.arguments ??= '';\n            choice.message.function_call.arguments += function_call.arguments;\n          }\n        }\n      }\n      if (tool_calls) {\n        if (!choice.message.tool_calls) choice.message.tool_calls = [];\n        for (const { index, id, type, function: fn, ...rest } of tool_calls) {\n          const tool_call = (choice.message.tool_calls[index] ??= {});\n          Object.assign(tool_call, rest);\n          if (id) tool_call.id = id;\n          if (type) tool_call.type = type;\n          if (fn) tool_call.function ??= { arguments: '' };\n          if (fn?.name) tool_call.function!.name = fn.name;\n          if (fn?.arguments) tool_call.function!.arguments += fn.arguments;\n        }\n      }\n    }\n    return snapshot;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<ChatCompletionChunk> {\n    const pushQueue: ChatCompletionChunk[] = [];\n    const readQueue: {\n      resolve: (chunk: ChatCompletionChunk | undefined) => void;\n      reject: (err: unknown) => void;\n    }[] = [];\n    let done = false;\n\n    this.on('chunk', (chunk) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('abort', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('error', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<ChatCompletionChunk>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<ChatCompletionChunk | undefined>((resolve, reject) =>\n            readQueue.push({ resolve, reject }),\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n      return: async () => {\n        this.abort();\n        return { value: undefined, done: true };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n\nfunction finalizeChatCompletion(snapshot: ChatCompletionSnapshot): ChatCompletion {\n  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;\n  return {\n    ...rest,\n    id,\n    choices: choices.map(\n      ({ message, finish_reason, index, logprobs, ...choiceRest }): ChatCompletion.Choice => {\n        if (!finish_reason) throw new OpenAIError(`missing finish_reason for choice ${index}`);\n        const { content = null, function_call, tool_calls, ...messageRest } = message;\n        const role = message.role as 'assistant'; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n        if (!role) throw new OpenAIError(`missing role for choice ${index}`);\n        if (function_call) {\n          const { arguments: args, name } = function_call;\n          if (args == null) throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n          if (!name) throw new OpenAIError(`missing function_call.name for choice ${index}`);\n          return {\n            ...choiceRest,\n            message: { content, function_call: { arguments: args, name }, role },\n            finish_reason,\n            index,\n            logprobs,\n          };\n        }\n        if (tool_calls) {\n          return {\n            ...choiceRest,\n            index,\n            finish_reason,\n            logprobs,\n            message: {\n              ...messageRest,\n              role,\n              content,\n              tool_calls: tool_calls.map((tool_call, i) => {\n                const { function: fn, type, id, ...toolRest } = tool_call;\n                const { arguments: args, name, ...fnRest } = fn || {};\n                if (id == null)\n                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n                if (type == null)\n                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n                if (name == null)\n                  throw new OpenAIError(\n                    `missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`,\n                  );\n                if (args == null)\n                  throw new OpenAIError(\n                    `missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`,\n                  );\n\n                return { ...toolRest, id, type, function: { ...fnRest, name, arguments: args } };\n              }),\n            },\n          };\n        }\n        return {\n          ...choiceRest,\n          message: { ...messageRest, content, role },\n          finish_reason,\n          index,\n          logprobs,\n        };\n      },\n    ),\n    created,\n    model,\n    object: 'chat.completion',\n    ...(system_fingerprint ? { system_fingerprint } : {}),\n  };\n}\n\nfunction str(x: unknown) {\n  return JSON.stringify(x);\n}\n\n/**\n * Represents a streamed chunk of a chat completion response returned by model,\n * based on the provided input.\n */\nexport interface ChatCompletionSnapshot {\n  /**\n   * A unique identifier for the chat completion.\n   */\n  id: string;\n\n  /**\n   * A list of chat completion choices. Can be more than one if `n` is greater\n   * than 1.\n   */\n  choices: Array<ChatCompletionSnapshot.Choice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the chat completion was created.\n   */\n  created: number;\n\n  /**\n   * The model to generate the completion.\n   */\n  model: string;\n\n  // Note we do not include an \"object\" type on the snapshot,\n  // because the object is not a valid \"chat.completion\" until finalized.\n  // object: 'chat.completion';\n\n  /**\n   * This fingerprint represents the backend configuration that the model runs with.\n   *\n   * Can be used in conjunction with the `seed` request parameter to understand when\n   * backend changes have been made that might impact determinism.\n   */\n  system_fingerprint?: string;\n}\n\nexport namespace ChatCompletionSnapshot {\n  export interface Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    message: Choice.Message;\n\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\n     * number of tokens specified in the request was reached, `content_filter` if\n     * content was omitted due to a flag from our content filters, or `function_call`\n     * if the model called a function.\n     */\n    finish_reason: ChatCompletion.Choice['finish_reason'] | null;\n\n    /**\n     * Log probability information for the choice.\n     */\n    logprobs: ChatCompletion.Choice.Logprobs | null;\n\n    /**\n     * The index of the choice in the list of choices.\n     */\n    index: number;\n  }\n\n  export namespace Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    export interface Message {\n      /**\n       * The contents of the chunk message.\n       */\n      content?: string | null;\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      function_call?: Message.FunctionCall;\n\n      tool_calls?: Array<Message.ToolCall>;\n\n      /**\n       * The role of the author of this message.\n       */\n      role?: 'system' | 'user' | 'assistant' | 'function' | 'tool';\n    }\n\n    export namespace Message {\n      export interface ToolCall {\n        /**\n         * The ID of the tool call.\n         */\n        id?: string;\n\n        function?: ToolCall.Function;\n\n        /**\n         * The type of the tool.\n         */\n        type?: 'function';\n      }\n\n      export namespace ToolCall {\n        export interface Function {\n          /**\n           * The arguments to call the function with, as generated by the model in JSON\n           * format. Note that the model does not always generate valid JSON, and may\n           * hallucinate parameters not defined by your function schema. Validate the\n           * arguments in your code before calling your function.\n           */\n          arguments?: string;\n\n          /**\n           * The name of the function to call.\n           */\n          name?: string;\n        }\n      }\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      export interface FunctionCall {\n        /**\n         * The arguments to call the function with, as generated by the model in JSON\n         * format. Note that the model does not always generate valid JSON, and may\n         * hallucinate parameters not defined by your function schema. Validate the\n         * arguments in your code before calling your function.\n         */\n        arguments?: string;\n\n        /**\n         * The name of the function to call.\n         */\n        name?: string;\n      }\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;SACSA,WAAW,EAAEC,iBAAiB,QAAQ,cAAc;SAS3DC,4BAA4B,QAE7B;SAEQC,MAAM,QAAQ,kBAAkB;AAWzC,OAAM,MAAOC,oBACX,SAAQF,4BAAwD;EADlEG,YAAA;;;IAIEC,mDAAA,CAAAC,GAAA;EAsPF;EApPE,IAAIC,6BAA6BA,CAAA;IAC/B,OAAOC,sBAAA,KAAI,EAAAH,mDAAA,MAA+B;EAC5C;EAEA;;;;;;;EAOA,OAAOI,kBAAkBA,CAACC,MAAsB;IAC9C,MAAMC,MAAM,GAAG,IAAIR,oBAAoB,EAAE;IACzCQ,MAAM,CAACC,IAAI,CAAC,MAAMD,MAAM,CAACE,mBAAmB,CAACH,MAAM,CAAC,CAAC;IACrD,OAAOC,MAAM;EACf;EAEA,OAAOG,oBAAoBA,CACzBC,WAAwB,EACxBC,MAAkC,EAClCC,OAA6B;IAE7B,MAAMN,MAAM,GAAG,IAAIR,oBAAoB,EAAE;IACzCQ,MAAM,CAACC,IAAI,CAAC,MACVD,MAAM,CAACO,kBAAkB,CACvBH,WAAW,EACX;MAAE,GAAGC,MAAM;MAAEN,MAAM,EAAE;IAAI,CAAE,EAC3B;MAAE,GAAGO,OAAO;MAAEE,OAAO,EAAE;QAAE,IAAGF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEE,OAAO;QAAE,2BAA2B,EAAE;MAAQ;IAAE,CAAE,CACxF,CACF;IACD,OAAOR,MAAM;EACf;EA4BmB,MAAMS,qBAAqBA,CAC5CL,WAAwB,EACxBC,MAAkC,EAClCC,OAA6B;IAAA,IAAAI,qBAAA;IAE7B,MAAMC,MAAM,GAAGL,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEK,MAAM;IAC9B,IAAIA,MAAM,EAAE;MACV,IAAIA,MAAM,CAACC,OAAO,EAAE,IAAI,CAACC,UAAU,CAACC,KAAK,EAAE;MAC3CH,MAAM,CAACI,gBAAgB,CAAC,OAAO,EAAE,MAAM,IAAI,CAACF,UAAU,CAACC,KAAK,EAAE,CAAC;;IAEjEjB,sBAAA,KAAI,EAAAmB,+BAAA,OAAAC,kCAAA,CAAc,CAAAC,IAAA,CAAlB,IAAI,CAAgB;IACpB,MAAMnB,MAAM,GAAG,MAAMK,WAAW,CAACe,MAAM,CACrC;MAAE,GAAGd,MAAM;MAAEN,MAAM,EAAE;IAAI,CAAE,EAC3B;MAAE,GAAGO,OAAO;MAAEK,MAAM,EAAE,IAAI,CAACE,UAAU,CAACF;IAAM,CAAE,CAC/C;IACD,IAAI,CAACS,UAAU,EAAE;IACjB,WAAW,MAAMC,KAAK,IAAItB,MAAM,EAAE;MAChCF,sBAAA,KAAI,EAAAmB,+BAAA,OAAAM,8BAAA,CAAU,CAAAJ,IAAA,CAAd,IAAI,EAAWG,KAAK,CAAC;;IAEvB,KAAAX,qBAAA,GAAIX,MAAM,CAACc,UAAU,CAACF,MAAM,cAAAD,qBAAA,eAAxBA,qBAAA,CAA0BE,OAAO,EAAE;MACrC,MAAM,IAAIvB,iBAAiB,EAAE;;IAE/B,OAAO,IAAI,CAACkC,kBAAkB,CAAC1B,sBAAA,KAAI,EAAAmB,+BAAA,OAAAQ,gCAAA,CAAY,CAAAN,IAAA,CAAhB,IAAI,CAAc,CAAC;EACpD;EAEU,MAAMhB,mBAAmBA,CACjCuB,cAA8B,EAC9BnB,OAA6B;IAAA,IAAAoB,sBAAA;IAE7B,MAAMf,MAAM,GAAGL,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEK,MAAM;IAC9B,IAAIA,MAAM,EAAE;MACV,IAAIA,MAAM,CAACC,OAAO,EAAE,IAAI,CAACC,UAAU,CAACC,KAAK,EAAE;MAC3CH,MAAM,CAACI,gBAAgB,CAAC,OAAO,EAAE,MAAM,IAAI,CAACF,UAAU,CAACC,KAAK,EAAE,CAAC;;IAEjEjB,sBAAA,KAAI,EAAAmB,+BAAA,OAAAC,kCAAA,CAAc,CAAAC,IAAA,CAAlB,IAAI,CAAgB;IACpB,IAAI,CAACE,UAAU,EAAE;IACjB,MAAMrB,MAAM,GAAGR,MAAM,CAACO,kBAAkB,CAAsB2B,cAAc,EAAE,IAAI,CAACZ,UAAU,CAAC;IAC9F,IAAIc,MAAM;IACV,WAAW,MAAMN,KAAK,IAAItB,MAAM,EAAE;MAChC,IAAI4B,MAAM,IAAIA,MAAM,KAAKN,KAAK,CAACO,EAAE,EAAE;QACjC;QACA,IAAI,CAACL,kBAAkB,CAAC1B,sBAAA,KAAI,EAAAmB,+BAAA,OAAAQ,gCAAA,CAAY,CAAAN,IAAA,CAAhB,IAAI,CAAc,CAAC;;MAG7CrB,sBAAA,KAAI,EAAAmB,+BAAA,OAAAM,8BAAA,CAAU,CAAAJ,IAAA,CAAd,IAAI,EAAWG,KAAK,CAAC;MACrBM,MAAM,GAAGN,KAAK,CAACO,EAAE;;IAEnB,KAAAF,sBAAA,GAAI3B,MAAM,CAACc,UAAU,CAACF,MAAM,cAAAe,sBAAA,eAAxBA,sBAAA,CAA0Bd,OAAO,EAAE;MACrC,MAAM,IAAIvB,iBAAiB,EAAE;;IAE/B,OAAO,IAAI,CAACkC,kBAAkB,CAAC1B,sBAAA,KAAI,EAAAmB,+BAAA,OAAAQ,gCAAA,CAAY,CAAAN,IAAA,CAAhB,IAAI,CAAc,CAAC;EACpD;EAqEA,EAAAxB,mDAAA,OAAAmC,OAAA,IAAAb,+BAAA,OAAAc,OAAA,IAAAb,kCAAA,YAAAA,mCAAA;IAjJE,IAAI,IAAI,CAACc,KAAK,EAAE;IAChBC,sBAAA,KAAI,EAAAtC,mDAAA,EAAkCuC,SAAS;EACjD,CAAC,EAAAX,8BAAA,YAAAA,+BACSD,KAA0B;IAAA,IAAAa,eAAA,EAAAC,oBAAA;IAClC,IAAI,IAAI,CAACJ,KAAK,EAAE;IAChB,MAAMK,UAAU,GAAGvC,sBAAA,KAAI,EAAAmB,+BAAA,OAAAqB,8CAAA,CAA0B,CAAAnB,IAAA,CAA9B,IAAI,EAA2BG,KAAK,CAAC;IACxD,IAAI,CAACiB,KAAK,CAAC,OAAO,EAAEjB,KAAK,EAAEe,UAAU,CAAC;IACtC,MAAMG,KAAK,IAAAL,eAAA,GAAGb,KAAK,CAACmB,OAAO,CAAC,CAAC,CAAC,cAAAN,eAAA,gBAAAA,eAAA,GAAhBA,eAAA,CAAkBK,KAAK,cAAAL,eAAA,uBAAvBA,eAAA,CAAyBO,OAAO;IAC9C,MAAMC,QAAQ,IAAAP,oBAAA,GAAGC,UAAU,CAACI,OAAO,CAAC,CAAC,CAAC,cAAAL,oBAAA,uBAArBA,oBAAA,CAAuBQ,OAAO;IAC/C,IAAIJ,KAAK,IAAI,IAAI,IAAI,CAAAG,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEE,IAAI,MAAK,WAAW,IAAIF,QAAQ,aAARA,QAAQ,eAARA,QAAQ,CAAED,OAAO,EAAE;MACxE,IAAI,CAACH,KAAK,CAAC,SAAS,EAAEC,KAAK,EAAEG,QAAQ,CAACD,OAAO,CAAC;;EAElD,CAAC,EAAAjB,gCAAA,YAAAA,iCAAA;IAEC,IAAI,IAAI,CAACO,KAAK,EAAE;MACd,MAAM,IAAI3C,WAAW,0CAA0C,CAAC;;IAElE,MAAMsD,QAAQ,GAAG7C,sBAAA,KAAI,EAAAH,mDAAA,MAA+B;IACpD,IAAI,CAACgD,QAAQ,EAAE;MACb,MAAM,IAAItD,WAAW,2CAA2C,CAAC;;IAEnE4C,sBAAA,KAAI,EAAAtC,mDAAA,EAAkCuC,SAAS;IAC/C,OAAOY,sBAAsB,CAACH,QAAQ,CAAC;EACzC,CAAC,EAAAL,8CAAA,YAAAA,+CAuDyBhB,KAA0B;;IAClD,IAAIqB,QAAQ,GAAG7C,sBAAA,KAAI,EAAAH,mDAAA,MAA+B;IAClD,MAAM;MAAE8C,OAAO;MAAE,GAAGM;IAAI,CAAE,GAAGzB,KAAK;IAClC,IAAI,CAACqB,QAAQ,EAAE;MACbA,QAAQ,GAAGV,sBAAA,KAAI,EAAAtC,mDAAA,EAAkC;QAC/C,GAAGoD,IAAI;QACPN,OAAO,EAAE;OACV;KACF,MAAM;MACLO,MAAM,CAACC,MAAM,CAACN,QAAQ,EAAEI,IAAI,CAAC;;IAG/B,KAAK,MAAM;MAAEP,KAAK;MAAEU,aAAa;MAAEC,KAAK;MAAEC,QAAQ,GAAG,IAAI;MAAE,GAAGC;IAAK,CAAE,IAAI/B,KAAK,CAACmB,OAAO,EAAE;MACtF,IAAIa,MAAM,GAAGX,QAAQ,CAACF,OAAO,CAACU,KAAK,CAAC;MACpC,IAAI,CAACG,MAAM,EAAE;QACXA,MAAM,GAAGX,QAAQ,CAACF,OAAO,CAACU,KAAK,CAAC,GAAG;UAAED,aAAa;UAAEC,KAAK;UAAEP,OAAO,EAAE,EAAE;UAAEQ,QAAQ;UAAE,GAAGC;QAAK,CAAE;;MAG9F,IAAID,QAAQ,EAAE;QACZ,IAAI,CAACE,MAAM,CAACF,QAAQ,EAAE;UACpBE,MAAM,CAACF,QAAQ,GAAGJ,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEG,QAAQ,CAAC;SAC9C,MAAM;UACL,MAAM;YAAEV,OAAO;YAAE,GAAGK;UAAI,CAAE,GAAGK,QAAQ;UACrCJ,MAAM,CAACC,MAAM,CAACK,MAAM,CAACF,QAAQ,EAAEL,IAAI,CAAC;UACpC,IAAIL,OAAO,EAAE;YAAA,IAAAa,UAAA;YACX,CAAAA,UAAA,IAAAC,EAAA,GAAAF,MAAM,CAACF,QAAQ,EAACV,OAAO,cAAAa,UAAA,cAAAA,UAAA,GAAAC,EAAA,CAAPd,OAAO,GAAK,EAAE;YAC9BY,MAAM,CAACF,QAAQ,CAACV,OAAO,CAACe,IAAI,CAAC,GAAGf,OAAO,CAAC;;;;MAK9C,IAAIQ,aAAa,EAAEI,MAAM,CAACJ,aAAa,GAAGA,aAAa;MACvDF,MAAM,CAACC,MAAM,CAACK,MAAM,EAAED,KAAK,CAAC;MAE5B,IAAI,CAACb,KAAK,EAAE,SAAS,CAAC;MACtB,MAAM;QAAEE,OAAO;QAAEgB,aAAa;QAAEb,IAAI;QAAEc,UAAU;QAAE,GAAGZ;MAAI,CAAE,GAAGP,KAAK;MACnEQ,MAAM,CAACC,MAAM,CAACK,MAAM,CAACV,OAAO,EAAEG,IAAI,CAAC;MAEnC,IAAIL,OAAO,EAAEY,MAAM,CAACV,OAAO,CAACF,OAAO,GAAG,CAACY,MAAM,CAACV,OAAO,CAACF,OAAO,IAAI,EAAE,IAAIA,OAAO;MAC9E,IAAIG,IAAI,EAAES,MAAM,CAACV,OAAO,CAACC,IAAI,GAAGA,IAAI;MACpC,IAAIa,aAAa,EAAE;QACjB,IAAI,CAACJ,MAAM,CAACV,OAAO,CAACc,aAAa,EAAE;UACjCJ,MAAM,CAACV,OAAO,CAACc,aAAa,GAAGA,aAAa;SAC7C,MAAM;UACL,IAAIA,aAAa,CAACE,IAAI,EAAEN,MAAM,CAACV,OAAO,CAACc,aAAa,CAACE,IAAI,GAAGF,aAAa,CAACE,IAAI;UAC9E,IAAIF,aAAa,CAACG,SAAS,EAAE;YAAA,IAAAC,YAAA;YAC3B,CAAAA,YAAA,IAAAC,EAAA,GAAAT,MAAM,CAACV,OAAO,CAACc,aAAa,EAACG,SAAS,cAAAC,YAAA,cAAAA,YAAA,GAAAC,EAAA,CAATF,SAAS,GAAK,EAAE;YAC7CP,MAAM,CAACV,OAAO,CAACc,aAAa,CAACG,SAAS,IAAIH,aAAa,CAACG,SAAS;;;;MAIvE,IAAIF,UAAU,EAAE;QACd,IAAI,CAACL,MAAM,CAACV,OAAO,CAACe,UAAU,EAAEL,MAAM,CAACV,OAAO,CAACe,UAAU,GAAG,EAAE;QAC9D,KAAK,MAAM;UAAER,KAAK;UAAEtB,EAAE;UAAEmC,IAAI;UAAEC,QAAQ,EAAEC,EAAE;UAAE,GAAGnB;QAAI,CAAE,IAAIY,UAAU,EAAE;UAAA,IAAAQ,QAAA,EAAAC,mBAAA;UACnE,MAAMC,SAAS,IAAAF,QAAA,GAAG,CAAAG,EAAA,GAAChB,MAAM,CAACV,OAAO,CAACe,UAAU,EAACR,KAAK,eAAAgB,QAAA,cAAAA,QAAA,GAAAG,EAAA,CAALnB,KAAK,IAAM,EAAG;UAC3DH,MAAM,CAACC,MAAM,CAACoB,SAAS,EAAEtB,IAAI,CAAC;UAC9B,IAAIlB,EAAE,EAAEwC,SAAS,CAACxC,EAAE,GAAGA,EAAE;UACzB,IAAImC,IAAI,EAAEK,SAAS,CAACL,IAAI,GAAGA,IAAI;UAC/B,IAAIE,EAAE,EAAE,CAAAE,mBAAA,GAAAC,SAAS,CAACJ,QAAQ,cAAAG,mBAAA,cAAAA,mBAAA,GAAlBC,SAAS,CAACJ,QAAQ,GAAK;YAAEJ,SAAS,EAAE;UAAE,CAAE;UAChD,IAAIK,EAAE,aAAFA,EAAE,eAAFA,EAAE,CAAEN,IAAI,EAAES,SAAS,CAACJ,QAAS,CAACL,IAAI,GAAGM,EAAE,CAACN,IAAI;UAChD,IAAIM,EAAE,aAAFA,EAAE,eAAFA,EAAE,CAAEL,SAAS,EAAEQ,SAAS,CAACJ,QAAS,CAACJ,SAAS,IAAIK,EAAE,CAACL,SAAS;;;;IAItE,OAAOlB,QAAQ;EACjB,CAAC,EAEA4B,MAAM,CAACC,aAAa,KAAC;IACpB,MAAMC,SAAS,GAA0B,EAAE;IAC3C,MAAMC,SAAS,GAGT,EAAE;IACR,IAAIC,IAAI,GAAG,KAAK;IAEhB,IAAI,CAACC,EAAE,CAAC,OAAO,EAAGtD,KAAK,IAAI;MACzB,MAAMuD,MAAM,GAAGH,SAAS,CAACI,KAAK,EAAE;MAChC,IAAID,MAAM,EAAE;QACVA,MAAM,CAACE,OAAO,CAACzD,KAAK,CAAC;OACtB,MAAM;QACLmD,SAAS,CAAChB,IAAI,CAACnC,KAAK,CAAC;;IAEzB,CAAC,CAAC;IAEF,IAAI,CAACsD,EAAE,CAAC,KAAK,EAAE,MAAK;MAClBD,IAAI,GAAG,IAAI;MACX,KAAK,MAAME,MAAM,IAAIH,SAAS,EAAE;QAC9BG,MAAM,CAACE,OAAO,CAAC7C,SAAS,CAAC;;MAE3BwC,SAAS,CAACM,MAAM,GAAG,CAAC;IACtB,CAAC,CAAC;IAEF,IAAI,CAACJ,EAAE,CAAC,OAAO,EAAGK,GAAG,IAAI;MACvBN,IAAI,GAAG,IAAI;MACX,KAAK,MAAME,MAAM,IAAIH,SAAS,EAAE;QAC9BG,MAAM,CAACK,MAAM,CAACD,GAAG,CAAC;;MAEpBP,SAAS,CAACM,MAAM,GAAG,CAAC;IACtB,CAAC,CAAC;IAEF,IAAI,CAACJ,EAAE,CAAC,OAAO,EAAGK,GAAG,IAAI;MACvBN,IAAI,GAAG,IAAI;MACX,KAAK,MAAME,MAAM,IAAIH,SAAS,EAAE;QAC9BG,MAAM,CAACK,MAAM,CAACD,GAAG,CAAC;;MAEpBP,SAAS,CAACM,MAAM,GAAG,CAAC;IACtB,CAAC,CAAC;IAEF,OAAO;MACLG,IAAI,EAAE,MAAAA,CAAA,KAAyD;QAC7D,IAAI,CAACV,SAAS,CAACO,MAAM,EAAE;UACrB,IAAIL,IAAI,EAAE;YACR,OAAO;cAAES,KAAK,EAAElD,SAAS;cAAEyC,IAAI,EAAE;YAAI,CAAE;;UAEzC,OAAO,IAAIU,OAAO,CAAkC,CAACN,OAAO,EAAEG,MAAM,KAClER,SAAS,CAACjB,IAAI,CAAC;YAAEsB,OAAO;YAAEG;UAAM,CAAE,CAAC,CACpC,CAACI,IAAI,CAAEhE,KAAK,IAAMA,KAAK,GAAG;YAAE8D,KAAK,EAAE9D,KAAK;YAAEqD,IAAI,EAAE;UAAK,CAAE,GAAG;YAAES,KAAK,EAAElD,SAAS;YAAEyC,IAAI,EAAE;UAAI,CAAG,CAAC;;QAE/F,MAAMrD,KAAK,GAAGmD,SAAS,CAACK,KAAK,EAAG;QAChC,OAAO;UAAEM,KAAK,EAAE9D,KAAK;UAAEqD,IAAI,EAAE;QAAK,CAAE;MACtC,CAAC;MACDY,MAAM,EAAE,MAAAA,CAAA,KAAW;QACjB,IAAI,CAACxE,KAAK,EAAE;QACZ,OAAO;UAAEqE,KAAK,EAAElD,SAAS;UAAEyC,IAAI,EAAE;QAAI,CAAE;MACzC;KACD;EACH;EAEAa,gBAAgBA,CAAA;IACd,MAAMxF,MAAM,GAAG,IAAIR,MAAM,CAAC,IAAI,CAAC+E,MAAM,CAACC,aAAa,CAAC,CAACiB,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC3E,UAAU,CAAC;IACjF,OAAOd,MAAM,CAACwF,gBAAgB,EAAE;EAClC;;AAGF,SAAS1C,sBAAsBA,CAACH,QAAgC;EAC9D,MAAM;IAAEd,EAAE;IAAEY,OAAO;IAAEiD,OAAO;IAAEC,KAAK;IAAEC,kBAAkB;IAAE,GAAG7C;EAAI,CAAE,GAAGJ,QAAQ;EAC7E,OAAO;IACL,GAAGI,IAAI;IACPlB,EAAE;IACFY,OAAO,EAAEA,OAAO,CAACoD,GAAG,CAClBC,IAAA,IAAsF;MAAA,IAArF;QAAElD,OAAO;QAAEM,aAAa;QAAEC,KAAK;QAAEC,QAAQ;QAAE,GAAG2C;MAAU,CAAE,GAAAD,IAAA;MACzD,IAAI,CAAC5C,aAAa,EAAE,MAAM,IAAI7D,WAAW,qCAAA2G,MAAA,CAAqC7C,KAAK,CAAE,CAAC;MACtF,MAAM;QAAET,OAAO,GAAG,IAAI;QAAEgB,aAAa;QAAEC,UAAU;QAAE,GAAGsC;MAAW,CAAE,GAAGrD,OAAO;MAC7E,MAAMC,IAAI,GAAGD,OAAO,CAACC,IAAmB,CAAC,CAAC;MAC1C,IAAI,CAACA,IAAI,EAAE,MAAM,IAAIxD,WAAW,4BAAA2G,MAAA,CAA4B7C,KAAK,CAAE,CAAC;MACpE,IAAIO,aAAa,EAAE;QACjB,MAAM;UAAEG,SAAS,EAAEqC,IAAI;UAAEtC;QAAI,CAAE,GAAGF,aAAa;QAC/C,IAAIwC,IAAI,IAAI,IAAI,EAAE,MAAM,IAAI7G,WAAW,+CAAA2G,MAAA,CAA+C7C,KAAK,CAAE,CAAC;QAC9F,IAAI,CAACS,IAAI,EAAE,MAAM,IAAIvE,WAAW,0CAAA2G,MAAA,CAA0C7C,KAAK,CAAE,CAAC;QAClF,OAAO;UACL,GAAG4C,UAAU;UACbnD,OAAO,EAAE;YAAEF,OAAO;YAAEgB,aAAa,EAAE;cAAEG,SAAS,EAAEqC,IAAI;cAAEtC;YAAI,CAAE;YAAEf;UAAI,CAAE;UACpEK,aAAa;UACbC,KAAK;UACLC;SACD;;MAEH,IAAIO,UAAU,EAAE;QACd,OAAO;UACL,GAAGoC,UAAU;UACb5C,KAAK;UACLD,aAAa;UACbE,QAAQ;UACRR,OAAO,EAAE;YACP,GAAGqD,WAAW;YACdpD,IAAI;YACJH,OAAO;YACPiB,UAAU,EAAEA,UAAU,CAACkC,GAAG,CAAC,CAACxB,SAAS,EAAE8B,CAAC,KAAI;cAC1C,MAAM;gBAAElC,QAAQ,EAAEC,EAAE;gBAAEF,IAAI;gBAAEnC,EAAE;gBAAE,GAAGuE;cAAQ,CAAE,GAAG/B,SAAS;cACzD,MAAM;gBAAER,SAAS,EAAEqC,IAAI;gBAAEtC,IAAI;gBAAE,GAAGyC;cAAM,CAAE,GAAGnC,EAAE,IAAI,EAAE;cACrD,IAAIrC,EAAE,IAAI,IAAI,EACZ,MAAM,IAAIxC,WAAW,oBAAA2G,MAAA,CAAoB7C,KAAK,mBAAA6C,MAAA,CAAgBG,CAAC,YAAAH,MAAA,CAASM,GAAG,CAAC3D,QAAQ,CAAC,CAAE,CAAC;cAC1F,IAAIqB,IAAI,IAAI,IAAI,EACd,MAAM,IAAI3E,WAAW,oBAAA2G,MAAA,CAAoB7C,KAAK,mBAAA6C,MAAA,CAAgBG,CAAC,cAAAH,MAAA,CAAWM,GAAG,CAAC3D,QAAQ,CAAC,CAAE,CAAC;cAC5F,IAAIiB,IAAI,IAAI,IAAI,EACd,MAAM,IAAIvE,WAAW,oBAAA2G,MAAA,CACA7C,KAAK,mBAAA6C,MAAA,CAAgBG,CAAC,uBAAAH,MAAA,CAAoBM,GAAG,CAAC3D,QAAQ,CAAC,CAAE,CAC7E;cACH,IAAIuD,IAAI,IAAI,IAAI,EACd,MAAM,IAAI7G,WAAW,oBAAA2G,MAAA,CACA7C,KAAK,mBAAA6C,MAAA,CAAgBG,CAAC,4BAAAH,MAAA,CAAyBM,GAAG,CAAC3D,QAAQ,CAAC,CAAE,CAClF;cAEH,OAAO;gBAAE,GAAGyD,QAAQ;gBAAEvE,EAAE;gBAAEmC,IAAI;gBAAEC,QAAQ,EAAE;kBAAE,GAAGoC,MAAM;kBAAEzC,IAAI;kBAAEC,SAAS,EAAEqC;gBAAI;cAAE,CAAE;YAClF,CAAC;;SAEJ;;MAEH,OAAO;QACL,GAAGH,UAAU;QACbnD,OAAO,EAAE;UAAE,GAAGqD,WAAW;UAAEvD,OAAO;UAAEG;QAAI,CAAE;QAC1CK,aAAa;QACbC,KAAK;QACLC;OACD;IACH,CAAC,CACF;IACDsC,OAAO;IACPC,KAAK;IACLY,MAAM,EAAE,iBAAiB;IACzB,IAAIX,kBAAkB,GAAG;MAAEA;IAAkB,CAAE,GAAG,EAAE;GACrD;AACH;AAEA,SAASU,GAAGA,CAACE,CAAU;EACrB,OAAOC,IAAI,CAACC,SAAS,CAACF,CAAC,CAAC;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}